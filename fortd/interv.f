C
         SUBROUTINE INTERV ( XT, LXT, X, LEFT, MFLAG )
C
C     FROM  * A PRACTICAL GUIDE TO SPLINES *  BY C. DE BOOR
C.*COMPUTES  LEFT = MAX( I :  XT(I) .LT. XT(LXT) .AND.  XT(I) .LE. +  X ).
C
C.*****  I N P U T  ******
C     XT.....A REAL SEQUENCE, OF LENGTH  LXT , ASSUMED TO BE NONDECREASING
C     LXT.....NUMBER OF TERMS IN THE SEQUENCE  XT .
C     X.....THE POINT WHOSE LOCATION WITH RESPECT TO THE SEQUENCE  XT  IS
C     TO BE DETERMINED.
C
C.*****  O U T P U T  ******
C     LEFT, MFLAG.....BOTH INTEGERS, WHOSE VALUE IS
C
C     1     -1      IF               X .LT.  XT(1)
C     I      0      IF   XT(I)  .LE. X .LT. XT(I+1)
C     I      0      IF   XT(I)  .LT. X .EQ. XT(I+1) .EQ. XT(LXT)
C     I      1      IF   XT(I)  .LT.        XT(I+1) .EQ. XT(LXT) .LT. X
C
C     IN PARTICULAR,  MFLAG = 0  IS THE 'USUAL' CASE.  MFLAG .NE. 0
C     INDICATES THAT  X  LIES OUTSIDE THE CLOSED INTERVAL
C     XT(1) .LE. Y .LE. XT(LXT) . THE ASYMMETRIC TREATMENT OF THE
C     INTERVALS IS DUE TO THE DECISION TO MAKE ALL PP FUNCTIONS CONT-
C     INUOUS FROM THE RIGHT, BUT, BY RETURNING  MFLAG = 0  EVEN IF
C     X = XT(LXT), THERE IS THE OPTION OF HAVING THE COMPUTED PP FUNCTION
C     CONTINUOUS FROM THE LEFT AT  XT(LXT) .
C
C.*****  M E T H O D  ******
C     THE PROGRAM IS DESIGNED TO BE EFFICIENT IN THE COMMON SITUATION THAT
C     IT IS CALLED REPEATEDLY, WITH  X  TAKEN FROM AN INCREASING OR DECREA-
C     SING SEQUENCE. THIS WILL HAPPEN, E.G., WHEN A PP FUNCTION IS TO BE
C     GRAPHED. THE FIRST GUESS FOR  LEFT  IS THEREFORE TAKEN TO BE THE VAL-
C     UE RETURNED AT THE PREVIOUS CALL AND STORED IN THE  L O C A L  VARIA-
C     BLE  ILO . A FIRST CHECK ASCERTAINS THAT  ILO .LT. LXT (THIS IS NEC-
C     ESSARY SINCE THE PRESENT CALL MAY HAVE NOTHING TO DO WITH THE PREVI-
C     OUS CALL). THEN, IF  XT(ILO) .LE. X .LT. XT(ILO+1), WE SET  LEFT =
C     ILO  AND ARE DONE AFTER JUST THREE COMPARISONS.
C     OTHERWISE, WE REPEATEDLY DOUBLE THE DIFFERENCE  ISTEP = IHI - ILO
C     WHILE ALSO MOVING  ILO  AND  IHI  IN THE DIRECTION OF  X , UNTIL
C     XT(ILO) .LE. X .LT. XT(IHI) ,
C     AFTER WHICH WE USE BISECTION TO GET, IN ADDITION, ILO+1 = IHI .
C     LEFT = ILO  IS THEN RETURNED.
C
         INTEGER LEFT,LXT,MFLAG, IHI,ILO,ISTEP,MIDDLE
         REAL X,XT(LXT)
         DATA ILO /1/
         SAVE ILO
         IHI = ILO + 1
         IF (IHI .LT. LXT) GO TO 1
         IF (X .GE. XT(LXT)) GO TO 11
         IF (LXT .LE. 1) GO TO 9
         ILO = LXT - 1
         IHI = LXT
C
    1    IF (X .GE. XT(IHI)) GO TO 4
         IF (X .GE. XT(ILO)) GO TO 10
C
C     **** NOW X .LT. XT(ILO) . DECREASE  ILO  TO CAPTURE  X .
         ISTEP = 1
    2    IHI = ILO
         ILO = IHI - ISTEP
         IF (ILO .LE. 1) GO TO 3
         IF (X .GE. XT(ILO)) GO TO 7
         ISTEP = ISTEP*2
         GO TO 2
    3    ILO = 1
         IF (X .LT. XT(1)) GO TO 9
         GO TO 7
C     **** NOW X .GE. XT(IHI) . INCREASE  IHI  TO CAPTURE  X .
    4    ISTEP = 1
    5    ILO = IHI
         IHI = ILO + ISTEP
         IF (IHI .GE. LXT) GO TO 6
         IF (X .LT. XT(IHI)) GO TO 7
         ISTEP = ISTEP*2
         GO TO 5
    6    IF (X .GE. XT(LXT)) GO TO 11
         IHI = LXT
C
C     **** NOW XT(ILO) .LE. X .LT. XT(IHI) . NARROW THE INTERVAL.
    7    MIDDLE = (ILO + IHI)/2
         IF (MIDDLE .EQ. ILO) GO TO 10
C     NOTE. IT IS ASSUMED THAT MIDDLE = ILO IN CASE IHI = ILO+1 .
         IF (X .LT. XT(MIDDLE)) GO TO 8
         ILO = MIDDLE
         GO TO 7
    8    IHI = MIDDLE
         GO TO 7
C.*** SET OUTPUT AND RETURN.
    9    MFLAG = -1
         LEFT = 1
         RETURN
   10    MFLAG = 0
         LEFT = ILO
         RETURN
   11    MFLAG = 1
         IF (X .EQ. XT(LXT)) MFLAG = 0
         LEFT = LXT
   12    IF (LEFT .EQ. 1) RETURN
         LEFT = LEFT - 1
         IF (XT(LEFT) .LT. XT(LXT)) RETURN
         GO TO 12
         END
